// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createStep = `-- name: CreateStep :one
INSERT INTO steps (
  id, trace_id, parent_step_id, step_name, status, input, output, reasoning, started_at, ended_at, order_index
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, trace_id, parent_step_id, step_name, status, input, output, reasoning, started_at, ended_at, order_index
`

type CreateStepParams struct {
	ID           string          `json:"id"`
	TraceID      string          `json:"trace_id"`
	ParentStepID sql.NullString  `json:"parent_step_id"`
	StepName     string          `json:"step_name"`
	Status       string          `json:"status"`
	Input        json.RawMessage `json:"input"`
	Output       json.RawMessage `json:"output"`
	Reasoning    sql.NullString  `json:"reasoning"`
	StartedAt    time.Time       `json:"started_at"`
	EndedAt      sql.NullTime    `json:"ended_at"`
	OrderIndex   int64           `json:"order_index"`
}

func (q *Queries) CreateStep(ctx context.Context, arg CreateStepParams) (Step, error) {
	row := q.db.QueryRowContext(ctx, createStep,
		arg.ID,
		arg.TraceID,
		arg.ParentStepID,
		arg.StepName,
		arg.Status,
		arg.Input,
		arg.Output,
		arg.Reasoning,
		arg.StartedAt,
		arg.EndedAt,
		arg.OrderIndex,
	)
	var i Step
	err := row.Scan(
		&i.ID,
		&i.TraceID,
		&i.ParentStepID,
		&i.StepName,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Reasoning,
		&i.StartedAt,
		&i.EndedAt,
		&i.OrderIndex,
	)
	return i, err
}

const createTrace = `-- name: CreateTrace :one
INSERT INTO traces (id, name, status, metadata, started_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, started_at, completed_at, status, metadata
`

type CreateTraceParams struct {
	ID        string          `json:"id"`
	Name      string          `json:"name"`
	Status    string          `json:"status"`
	Metadata  json.RawMessage `json:"metadata"`
	StartedAt time.Time       `json:"started_at"`
}

func (q *Queries) CreateTrace(ctx context.Context, arg CreateTraceParams) (Trace, error) {
	row := q.db.QueryRowContext(ctx, createTrace,
		arg.ID,
		arg.Name,
		arg.Status,
		arg.Metadata,
		arg.StartedAt,
	)
	var i Trace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.Metadata,
	)
	return i, err
}

const getTrace = `-- name: GetTrace :one
SELECT id, name, started_at, completed_at, status, metadata FROM traces
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTrace(ctx context.Context, id string) (Trace, error) {
	row := q.db.QueryRowContext(ctx, getTrace, id)
	var i Trace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.Metadata,
	)
	return i, err
}

const listStepsByTrace = `-- name: ListStepsByTrace :many
SELECT id, trace_id, parent_step_id, step_name, status, input, output, reasoning, started_at, ended_at, order_index FROM steps
WHERE trace_id = ?
ORDER BY order_index ASC
`

func (q *Queries) ListStepsByTrace(ctx context.Context, traceID string) ([]Step, error) {
	rows, err := q.db.QueryContext(ctx, listStepsByTrace, traceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Step
	for rows.Next() {
		var i Step
		if err := rows.Scan(
			&i.ID,
			&i.TraceID,
			&i.ParentStepID,
			&i.StepName,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.Reasoning,
			&i.StartedAt,
			&i.EndedAt,
			&i.OrderIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTraces = `-- name: ListTraces :many
SELECT id, name, started_at, completed_at, status, metadata FROM traces
ORDER BY started_at DESC
LIMIT 50
`

func (q *Queries) ListTraces(ctx context.Context) ([]Trace, error) {
	rows, err := q.db.QueryContext(ctx, listTraces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trace
	for rows.Next() {
		var i Trace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Status,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStep = `-- name: UpdateStep :one
UPDATE steps
SET status = ?, output = ?, reasoning = ?, ended_at = ?
WHERE id = ?
RETURNING id, trace_id, parent_step_id, step_name, status, input, output, reasoning, started_at, ended_at, order_index
`

type UpdateStepParams struct {
	Status    string          `json:"status"`
	Output    json.RawMessage `json:"output"`
	Reasoning sql.NullString  `json:"reasoning"`
	EndedAt   sql.NullTime    `json:"ended_at"`
	ID        string          `json:"id"`
}

func (q *Queries) UpdateStep(ctx context.Context, arg UpdateStepParams) (Step, error) {
	row := q.db.QueryRowContext(ctx, updateStep,
		arg.Status,
		arg.Output,
		arg.Reasoning,
		arg.EndedAt,
		arg.ID,
	)
	var i Step
	err := row.Scan(
		&i.ID,
		&i.TraceID,
		&i.ParentStepID,
		&i.StepName,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Reasoning,
		&i.StartedAt,
		&i.EndedAt,
		&i.OrderIndex,
	)
	return i, err
}

const updateTraceStatus = `-- name: UpdateTraceStatus :one
UPDATE traces
SET status = ?, completed_at = ?
WHERE id = ?
RETURNING id, name, started_at, completed_at, status, metadata
`

type UpdateTraceStatusParams struct {
	Status      string       `json:"status"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          string       `json:"id"`
}

func (q *Queries) UpdateTraceStatus(ctx context.Context, arg UpdateTraceStatusParams) (Trace, error) {
	row := q.db.QueryRowContext(ctx, updateTraceStatus, arg.Status, arg.CompletedAt, arg.ID)
	var i Trace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.Metadata,
	)
	return i, err
}
